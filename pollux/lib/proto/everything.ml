(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: proto/everything.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show]'
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec Everything : sig
  type t = {
    i32i:int;
    i64o:int option;
    u32r:int list;
    u64i:int;
    s32o:int option;
    s64r:int list;
    f32i:int32;
    f64o:int64 option;
    sf32r:int32 list;
    sf64i:int64;
    bo:bool option;
    sr:string list;
    bi:bytes;
  } [@@deriving show]
  val make: ?i32i:int -> ?i64o:int -> ?u32r:int list -> ?u64i:int -> ?s32o:int -> ?s64r:int list -> ?f32i:int32 -> ?f64o:int64 -> ?sf32r:int32 list -> ?sf64i:int64 -> ?bo:bool -> ?sr:string list -> ?bi:bytes -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?i32i:int -> ?i64o:int -> ?u32r:int list -> ?u64i:int -> ?s32o:int -> ?s64r:int list -> ?f32i:int32 -> ?f64o:int64 -> ?sf32r:int32 list -> ?sf64i:int64 -> ?bo:bool -> ?sr:string list -> ?bi:bytes -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = Everything
  let name () = ".everything"
  type t = {
    i32i:int;
    i64o:int option;
    u32r:int list;
    u64i:int;
    s32o:int option;
    s64r:int list;
    f32i:int32;
    f64o:int64 option;
    sf32r:int32 list;
    sf64i:int64;
    bo:bool option;
    sr:string list;
    bi:bytes;
  } [@@deriving show]
  type make_t = ?i32i:int -> ?i64o:int -> ?u32r:int list -> ?u64i:int -> ?s32o:int -> ?s64r:int list -> ?f32i:int32 -> ?f64o:int64 -> ?sf32r:int32 list -> ?sf64i:int64 -> ?bo:bool -> ?sr:string list -> ?bi:bytes -> unit -> t
  let make ?(i32i = 0) ?i64o ?(u32r = []) ?(u64i = 0) ?s32o ?(s64r = []) ?(f32i = 0l) ?f64o ?(sf32r = []) ?(sf64i = 0L) ?bo ?(sr = []) ?(bi = (Bytes.of_string {||})) () = { i32i; i64o; u32r; u64i; s32o; s64r; f32i; f64o; sf32r; sf64i; bo; sr; bi }
  let merge =
  let merge_i32i = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "i32i", "i32i"), int32_int, (0)) ) in
  let merge_i64o = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "i64o", "i64o"), int32_int) ) in
  let merge_u32r = Runtime'.Merge.merge Runtime'.Spec.( repeated ((4, "u32r", "u32r"), uint32_int, packed) ) in
  let merge_u64i = Runtime'.Merge.merge Runtime'.Spec.( basic ((5, "u64i", "u64i"), uint64_int, (0)) ) in
  let merge_s32o = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((6, "s32o", "s32o"), sint32_int) ) in
  let merge_s64r = Runtime'.Merge.merge Runtime'.Spec.( repeated ((7, "s64r", "s64r"), sint64_int, packed) ) in
  let merge_f32i = Runtime'.Merge.merge Runtime'.Spec.( basic ((8, "f32i", "f32i"), fixed32, (0l)) ) in
  let merge_f64o = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((9, "f64o", "f64o"), fixed64) ) in
  let merge_sf32r = Runtime'.Merge.merge Runtime'.Spec.( repeated ((10, "sf32r", "sf32r"), sfixed32, packed) ) in
  let merge_sf64i = Runtime'.Merge.merge Runtime'.Spec.( basic ((11, "sf64i", "sf64i"), sfixed64, (0L)) ) in
  let merge_bo = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((12, "bo", "bo"), bool) ) in
  let merge_sr = Runtime'.Merge.merge Runtime'.Spec.( repeated ((13, "sr", "sr"), string, not_packed) ) in
  let merge_bi = Runtime'.Merge.merge Runtime'.Spec.( basic ((14, "bi", "bi"), bytes, ((Bytes.of_string {||}))) ) in
  fun t1 t2 -> {
  	i32i = (merge_i32i t1.i32i t2.i32i);
  	i64o = (merge_i64o t1.i64o t2.i64o);
  	u32r = (merge_u32r t1.u32r t2.u32r);
  	u64i = (merge_u64i t1.u64i t2.u64i);
  	s32o = (merge_s32o t1.s32o t2.s32o);
  	s64r = (merge_s64r t1.s64r t2.s64r);
  	f32i = (merge_f32i t1.f32i t2.f32i);
  	f64o = (merge_f64o t1.f64o t2.f64o);
  	sf32r = (merge_sf32r t1.sf32r t2.sf32r);
  	sf64i = (merge_sf64i t1.sf64i t2.sf64i);
  	bo = (merge_bo t1.bo t2.bo);
  	sr = (merge_sr t1.sr t2.sr);
  	bi = (merge_bi t1.bi t2.bi);
   }
  let spec () = Runtime'.Spec.( basic ((1, "i32i", "i32i"), int32_int, (0)) ^:: basic_opt ((2, "i64o", "i64o"), int32_int) ^:: repeated ((4, "u32r", "u32r"), uint32_int, packed) ^:: basic ((5, "u64i", "u64i"), uint64_int, (0)) ^:: basic_opt ((6, "s32o", "s32o"), sint32_int) ^:: repeated ((7, "s64r", "s64r"), sint64_int, packed) ^:: basic ((8, "f32i", "f32i"), fixed32, (0l)) ^:: basic_opt ((9, "f64o", "f64o"), fixed64) ^:: repeated ((10, "sf32r", "sf32r"), sfixed32, packed) ^:: basic ((11, "sf64i", "sf64i"), sfixed64, (0L)) ^:: basic_opt ((12, "bo", "bo"), bool) ^:: repeated ((13, "sr", "sr"), string, not_packed) ^:: basic ((14, "bi", "bi"), bytes, ((Bytes.of_string {||}))) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer { i32i; i64o; u32r; u64i; s32o; s64r; f32i; f64o; sf32r; sf64i; bo; sr; bi } -> serialize writer i32i i64o u32r u64i s32o s64r f32i f64o sf32r sf64i bo sr bi

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor i32i i64o u32r u64i s32o s64r f32i f64o sf32r sf64i bo sr bi = { i32i; i64o; u32r; u64i; s32o; s64r; f32i; f64o; sf32r; sf64i; bo; sr; bi } in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun { i32i; i64o; u32r; u64i; s32o; s64r; f32i; f64o; sf32r; sf64i; bo; sr; bi } -> serialize i32i i64o u32r u64i s32o s64r f32i f64o sf32r sf64i bo sr bi
  let from_json_exn =
    let constructor i32i i64o u32r u64i s32o s64r f32i f64o sf32r sf64i bo sr bi = { i32i; i64o; u32r; u64i; s32o; s64r; f32i; f64o; sf32r; sf64i; bo; sr; bi } in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end


