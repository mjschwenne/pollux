(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: proto/varint.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show]'
    opens=[]
    int64_as_int=false
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=false
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec U32 : sig
  type t = (int) [@@deriving show]
  val make: ?field:int -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?field:int -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = U32
  let name () = ".u32"
  type t = (int) [@@deriving show]
  type make_t = ?field:int -> unit -> t
  let make ?(field = 0) () = (field)
  let merge =
  let merge_field = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "field", "field"), uint32_int, (0)) ) in
  fun (t1_field) (t2_field) -> merge_field t1_field t2_field
  let spec () = Runtime'.Spec.( basic ((1, "field", "field"), uint32_int, (0)) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer (field) -> serialize writer field

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun (field) -> serialize field
  let from_json_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end

and U64 : sig
  type t = (int64) [@@deriving show]
  val make: ?field:int64 -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?field:int64 -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = U64
  let name () = ".u64"
  type t = (int64) [@@deriving show]
  type make_t = ?field:int64 -> unit -> t
  let make ?(field = 0L) () = (field)
  let merge =
  let merge_field = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "field", "field"), uint64, (0L)) ) in
  fun (t1_field) (t2_field) -> merge_field t1_field t2_field
  let spec () = Runtime'.Spec.( basic ((1, "field", "field"), uint64, (0L)) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer (field) -> serialize writer field

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun (field) -> serialize field
  let from_json_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end

and I32 : sig
  type t = (int) [@@deriving show]
  val make: ?field:int -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?field:int -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = I32
  let name () = ".i32"
  type t = (int) [@@deriving show]
  type make_t = ?field:int -> unit -> t
  let make ?(field = 0) () = (field)
  let merge =
  let merge_field = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "field", "field"), int32_int, (0)) ) in
  fun (t1_field) (t2_field) -> merge_field t1_field t2_field
  let spec () = Runtime'.Spec.( basic ((1, "field", "field"), int32_int, (0)) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer (field) -> serialize writer field

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun (field) -> serialize field
  let from_json_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end

and I64 : sig
  type t = (int64) [@@deriving show]
  val make: ?field:int64 -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?field:int64 -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = I64
  let name () = ".i64"
  type t = (int64) [@@deriving show]
  type make_t = ?field:int64 -> unit -> t
  let make ?(field = 0L) () = (field)
  let merge =
  let merge_field = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "field", "field"), int64, (0L)) ) in
  fun (t1_field) (t2_field) -> merge_field t1_field t2_field
  let spec () = Runtime'.Spec.( basic ((1, "field", "field"), int64, (0L)) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer (field) -> serialize writer field

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun (field) -> serialize field
  let from_json_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end

and S32 : sig
  type t = (int) [@@deriving show]
  val make: ?field:int -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?field:int -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = S32
  let name () = ".s32"
  type t = (int) [@@deriving show]
  type make_t = ?field:int -> unit -> t
  let make ?(field = 0) () = (field)
  let merge =
  let merge_field = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "field", "field"), sint32_int, (0)) ) in
  fun (t1_field) (t2_field) -> merge_field t1_field t2_field
  let spec () = Runtime'.Spec.( basic ((1, "field", "field"), sint32_int, (0)) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer (field) -> serialize writer field

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun (field) -> serialize field
  let from_json_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end

and S64 : sig
  type t = (int64) [@@deriving show]
  val make: ?field:int64 -> unit -> t
  (** Helper function to generate a message using default values *)

  val to_proto: t -> Runtime'.Writer.t
  (** Serialize the message to binary format *)

  val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from binary format *)

  val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
  (** Serialize to Json (compatible with Yojson.Basic.t) *)

  val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
  (** Deserialize from Json (compatible with Yojson.Basic.t) *)

  val name: unit -> string
  (** Fully qualified protobuf name of this message *)

  (**/**)
  type make_t = ?field:int64 -> unit -> t
  val merge: t -> t -> t
  val to_proto': Runtime'.Writer.t -> t -> unit
  val from_proto_exn: Runtime'.Reader.t -> t
  val from_json_exn: Runtime'.Json.t -> t
  (**/**)
end = struct
  module This'_ = S64
  let name () = ".s64"
  type t = (int64) [@@deriving show]
  type make_t = ?field:int64 -> unit -> t
  let make ?(field = 0L) () = (field)
  let merge =
  let merge_field = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "field", "field"), sint64, (0L)) ) in
  fun (t1_field) (t2_field) -> merge_field t1_field t2_field
  let spec () = Runtime'.Spec.( basic ((1, "field", "field"), sint64, (0L)) ^:: nil )
  let to_proto' =
    let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
    fun writer (field) -> serialize writer field

  let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
  let from_proto_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
  let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
  let to_json options =
    let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
    fun (field) -> serialize field
  let from_json_exn =
    let constructor field = (field) in
    Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
  let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
end


